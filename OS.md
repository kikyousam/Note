# 操作系统
## 各种锁
### 1. 互斥锁，读写锁，自旋锁的区别
互斥锁和自旋锁的主要区别实在加锁失败的应对上。互斥锁加锁失败会释放CPU，由操作系统进行阻塞，用线程切换来应对。自旋锁加锁失败是通过忙等待来应对。两者没有优劣之分。互斥锁通常用在加锁时间长的代码，用来弥补线程上下文切换的开销。自旋锁常用在加锁时间比较短的代码上。
读写锁
读写锁有三种状态：读加锁状态、写加锁状态和不加锁状态 
只有一个线程可以占有写状态的锁，但可以有多个线程同时占有读状态锁，这也是它可以实现高并发的原因。当其处于写状态锁下，任何想要尝试获得锁的线程都会被阻塞，直到写状态锁被释放；所以读写锁非常适合资源的读操作远多于写操作的情况。
原文链接：https://blog.csdn.net/judgejames/article/details/87286397

### 2. 说说c++ move函数？
move是转移对象的所有权，所以我们可以move的是可以转移所有权的对象。
C++，我们可以移动右值，也可以把左值通过std::move变成右值，从而可以实现移动。

### 3. 说说c++的左值和右值？什么时候用到右值？
在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。
C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。

## 进程 线程 协程
### 1.协程和线程的区别？
协程基于线程，但相对于线程轻量很多，可理解为在用户层模拟线程操作；
每创建一个协程，都有一个内核态线程动态绑定，用户态下实现调度、切换，真正执行任务的还是内核线程。
线程的上下文切换都需要内核参与，而协程的上下文切换，完全由用户去控制，避免了大量的中断参与，减少了线程上下文切换与调度消耗的资源。
线程是操作系统层面的概念，协程是语言层面的概念
线程与协程最大的区别在于：线程是被动挂起恢复，协程是主动挂起恢复
### 2.线程的调度机制
线程的调度是指按照特定的机制为多个线程分配CPU的使用权。 有两种调度模型： 
- 分时调度模型 分时调度模型是让所有线程轮流获得CPU的使用权，并且平均分配每个线程占用的CPU的时间片。
- 抢占式调度模型

### 3.进程间通信
#### 3.1 Linux 下共享内存底层实现原理（不是api）


### 4.进程上下文切换
进程是由内核管理和调度的，所以进程的切换只能发生在内核态。
所以，进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。
通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：

### 5.进程调度
非抢占式调度和抢占式调度的主要区别就是有没有时间片，要不要时钟中断。
进程调度的原则，主要考虑一下5个要素：
- CPU利用率
- 系统吞吐量：单位时间系统完成进程的数量
- 周转时间： 一个进程运行，周转等待时间的总和。周转时间越短越好
- 等待时间： 进程处于就绪队列中的时间，等待时间越长，用户越不满意
- 响应时间：用户请求第一次提交到系统所用的时间。在交互式系统中，响应时间越长，用户越不满意
单核CPU常见算法（看小林coding加深理解）：
1. 先来先服务算法
2. 最短作业调度算法。优先选择运行时间最短的进程进行调度
3. 高响应比优先调度算法。按照优先权来进行调度，优先级越高的越先调度
4. 时间片轮转调度算法。
5. 最高优先级调度算法（注意和3区分）
6. 多级反馈队列（Multilevel Feedback Queue）调度算法是「时间片轮转算法」和「最高优先级算法」的综合和发展。

**进程优先级的字段[ PRI Nice ]CPU调度和进程优先级的关系**

## 内存管理
### 1.虚拟内存和物理内存的差别？
如果使用物理内存的话，有两个缺点。一是运行程序时必须要确保自己程序所用的地址空间没有被其他程序的地址空间占用，这样会非常麻烦。二是如果运行了一个恶意的程序，它可能会修改其他程序的内存空间。造成别的程序崩溃。
虚拟内存的存在就解决了这两个问题。
虚拟地址空间通常被认为是4G的连续内存空间。程序在寻址的时候需要完成从虚拟地址空间向实际物理地址空间的映射转换。这其中用到了页表。虚拟地址空间的优点是：节省了物理空间，提高了物理空间的内存利用率，程序不用担心自己的内存会不会别的内存占用，因为每个进程都有自己独立的虚拟地址空间。

### 2. 进程访问一个地址空间的过程？
每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址
所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上
进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录
页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）
当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常
缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。
原文链接：https://blog.csdn.net/lvyibin890/article/details/82217193

### 3.虚拟内存有哪些？
代码段，未初始化数据段，初始化数据段，堆区，共享区，栈区，操作系统内核。

### 4.虚拟内存的查询流程？
二级页表的查询流程：
**看王道考研补充**

### 5.在不同的进程中创建的malloc返回的内存值是否可能一样？
虽然malloc可能在两个给定的进程中返回相同的值，但这并不重要，因为：
- 在物理上，他们不是同一个地址。
- 进程不会在任何地方共享虚拟内存。


## 其他