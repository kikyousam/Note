# 操作系统
## 各种锁
### 1. 互斥锁，读写锁，自旋锁的区别
互斥锁和自旋锁的主要区别实在加锁失败的应对上。互斥锁加锁失败会释放CPU，由操作系统进行阻塞，用线程切换来应对。自旋锁加锁失败是通过忙等待来应对。两者没有优劣之分。互斥锁通常用在加锁时间长的代码，用来弥补线程上下文切换的开销。自旋锁常用在加锁时间比较短的代码上。
读写锁
读写锁有三种状态：读加锁状态、写加锁状态和不加锁状态 
只有一个线程可以占有写状态的锁，但可以有多个线程同时占有读状态锁，这也是它可以实现高并发的原因。当其处于写状态锁下，任何想要尝试获得锁的线程都会被阻塞，直到写状态锁被释放；所以读写锁非常适合资源的读操作远多于写操作的情况。
原文链接：https://blog.csdn.net/judgejames/article/details/87286397



## 进程 线程 协程
### 1.协程和线程的区别？
协程基于线程，但相对于线程轻量很多，可理解为在用户层模拟线程操作；
每创建一个协程，都有一个内核态线程动态绑定，用户态下实现调度、切换，真正执行任务的还是内核线程。
线程的上下文切换都需要内核参与，而协程的上下文切换，完全由用户去控制，避免了大量的中断参与，减少了线程上下文切换与调度消耗的资源。
线程是操作系统层面的概念，协程是语言层面的概念
线程与协程最大的区别在于：线程是被动挂起恢复，协程是主动挂起恢复
### 2.线程的调度机制
线程的调度是指按照特定的机制为多个线程分配CPU的使用权。 有两种调度模型： 
- 分时调度模型 分时调度模型是让所有线程轮流获得CPU的使用权，并且平均分配每个线程占用的CPU的时间片。
- 抢占式调度模型

### 3.进程间通信
#### 3.1 Linux 下共享内存底层实现原理（不是api）


### 4.进程上下文切换
进程是由内核管理和调度的，所以进程的切换只能发生在内核态。
所以，进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。
通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：

### 5.进程调度
非抢占式调度和抢占式调度的主要区别就是有没有时间片，要不要时钟中断。
进程调度的原则，主要考虑一下5个要素：
- CPU利用率
- 系统吞吐量：单位时间系统完成进程的数量
- 周转时间： 一个进程运行，周转等待时间的总和。周转时间越短越好
- 等待时间： 进程处于就绪队列中的时间，等待时间越长，用户越不满意
- 响应时间：用户请求第一次提交到系统所用的时间。在交互式系统中，响应时间越长，用户越不满意
单核CPU常见算法（看小林coding加深理解）：
1. 先来先服务算法
2. 最短作业调度算法。优先选择运行时间最短的进程进行调度
3. 高响应比优先调度算法。按照优先权来进行调度，优先级越高的越先调度
4. 时间片轮转调度算法。
5. 最高优先级调度算法（注意和3区分）
6. 多级反馈队列（Multilevel Feedback Queue）调度算法是「时间片轮转算法」和「最高优先级算法」的综合和发展。

**进程优先级的字段[ PRI Nice ]CPU调度和进程优先级的关系**

## 内存管理
### 1.虚拟内存和物理内存的差别？
如果使用物理内存的话，有两个缺点。一是运行程序时必须要确保自己程序所用的地址空间没有被其他程序的地址空间占用，这样会非常麻烦。二是如果运行了一个恶意的程序，它可能会修改其他程序的内存空间。造成别的程序崩溃。
虚拟内存的存在就解决了这两个问题。
虚拟地址空间通常被认为是4G的连续内存空间。程序在寻址的时候需要完成从虚拟地址空间向实际物理地址空间的映射转换。这其中用到了页表。虚拟地址空间的优点是：节省了物理空间，提高了物理空间的内存利用率，程序不用担心自己的内存会不会别的内存占用，因为每个进程都有自己独立的虚拟地址空间。

### 2. 进程访问一个地址空间的过程？
每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址
所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上
进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录
页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）
当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常
缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。
原文链接：https://blog.csdn.net/lvyibin890/article/details/82217193

### 3.虚拟内存有哪些？
代码段，未初始化数据段，初始化数据段，堆区，共享区，栈区，操作系统内核。

### 4.虚拟内存的查询流程？
二级页表的查询流程：
**看王道考研补充**

### 5.在不同的进程中创建的malloc返回的内存值是否可能一样？
虽然malloc可能在两个给定的进程中返回相同的值，但这并不重要，因为：
- 在物理上，他们不是同一个地址。
- 进程不会在任何地方共享虚拟内存。


## 其他
1.请你说说进程线程的区别？
	• 进程有独立的地址空间，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间；
	• 进程的上下文切换时间开销远远大于线程上下文切换时间，耗费资源较大，效率要差一些；
	• 线程的并发性比进程的并发性高
	• 每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制
	• 系统在运行的时候会为每个进程分配不同的内存空间 而对线程而言，除了 CPU 外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源；
	• 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
	
2.进程间通信的方式？
 管道、信号量、信号、共享内存、消息队列、socket

3.说一说进程有多少种状态，如何转换

 创建、就绪、执行、阻塞、终止
 -创建：一个进程启动，首先进入创建状态，需要获取系统资源创建进程控制块（PCB：Process Control Block）完成资源分配。
- 就绪状态：在创建状态完成之后，进程已经准备好，处于就绪状态，但是还未获得处理器资源，无法运行。
- 运行状态：获取处理器资源，被系统调度，如果具有时间片，开始进入运行状态。如果进程的时间片用完了就进入就绪状态。
- 阻塞状态：在运行状态期间，如果进行了阻塞的操作，此时进程暂时无法操作就进入到了阻塞状态，在这些操作完成后就进入就绪状态。
- 终止状态：进程结束或者被系统终止，进入终止状态。

4.进程地址空间中堆和栈的区别？

 堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：
（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；

（2）空间大小不同。每个进程拥有的栈大小要远远小于堆大小。理论上，进程可申请的堆大小为虚拟内存大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；

（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。

（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca()函数分配，但是栈的动态分配和堆是不同的，它的动态分配是由操作系统进行释放，无需我们手工实现。

（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。

（6）存放内容不同。栈中存放函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。


5.说一说进程调度算法有哪些？

进程调度
     说道进程调度，我们或许都有个疑问，为什么需要进程调度呢？进程调度的作用是什么？

     需要进程调度的理由很充分，即充分利用计算机系统中的CPU资源，让计算机能够多快好省的完成各种任务。为此，可在内存中存放数目远大于计算机系统内CPU个数的进程，让这些进程在操作系统的进程调度器下，能够让进程高效（高的吞吐量--throughput）、及时（低延迟--latency）、公平（fairness）地使用CPU。为此调度器可设计不同的调度算法来选择进程，这体现了进程调度的策略，同时还需并进一步通过进程的上下文切换（context switch）来完成进程切换，这体现了进程调度的机制。

    总体上说，我们需要何时调度（调度的时机）、是否能够在内核执行的任意位置进行调度（调度的方式）、如果完成进程切换（上下文切换）、如果选择“合适”的进程执行（调度策略/调度算法）、如果评价选择的合理性（进程调度的指标）。了解上述细节，也就可以说是了解了进程调度。

调度的类型（操作系统的三级调度）


   1. 作业调度--高级调度

        用于决定将外存上处于后备队列中的哪些作业调入内存，处于内存的就绪队列，准备执行。

   2. 进程调度--低级调度

        决定就绪队列中那个进程将获得处理机

   3. 交换调度--中级调度

         目的是提高内存的利用率和系统的吞吐量

调度的时机
    什么时候会发生进程调度呢，引起进程调度的因素有哪些，这些也就是进程的调度时机。

   1. 正在执行的进程执行完毕

   2. 执行中的进程因提出I/O请求或发生等事件而暂停执行。

   3. 时间片完成

   4. 在进程通信或同步过程中执行了某种原语操作，如P操作（wait操作）阻塞

   5. 高优先者进入

调度的方式
     这里按照是否剥夺的方式分为两种调度方式。

    1. 非剥夺方式（非抢占方式）

         一旦占用CPU，直至完成或阻塞

        不利用实时任务，不利用短作业；使用于批处理系统   

    2. 剥夺方式（抢占方式）    

        在一定情况下，可剥夺一进程占有的处理机

        抢占的原则有：短作业（进程）优先原则、时间片原则、优先权原则。


先来先服务（FCFS）调度算法、
短作业优先（SJF）调度算法、优先级调度算法、高响应比优先调度算法、
时间片轮转调度算法、多级反馈队列调度算法

6.说一说虚拟地址空间有哪些部分 
32位系统中，虚拟地址空间为 0 ~ 4G，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间，虚拟地址空间分布如下图：


内核空间
存放内核的代码和数据，所有进程的内核代码段都映射到同样的物理内存，并在内存中持续存在，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。
用户空间
用户空间给各个进程使用，也称为使用者空间。用户空间中的代码运行在较低的特权级别上，只能看到允许它们使用的部分系统资源，并且不能使用某些特定的系统功能，也不能直接访问内核空间和硬件设备，以及其他一些具体的使用限制。用户空间又大致细分为下列一些空间：
栈空间 局部变量，函数返回地址，参数，返回值
共享区
堆空间 动态申请的内存
BSS 段（未初始化数据段）未初始化或者初始化为0的全局变量和静态变量
DATA 段（已初始化数据段）初始化的全局变量和静态变量
TEXT 段（代码段）有只读字符串常量和代码程序
保留区



7.请你介绍一下死锁，产生的必要条件，产生的原因，怎么预防死锁

 死锁 两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。 

产生死锁的必要条件 虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件：
 - 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放； 
- 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放；
 - 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放； 
- 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合 {P0，P1，P2，···，Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。 

预防死锁 - 有序资源分配法 - 银行家算法


8.什么是孤儿进程，什么是僵尸进程，如何解决僵尸进程

孤儿进程 孤儿进程是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 init 进程（进程号为1）所收养，并且由 init 进程对它们完整状态收集工作，孤儿进程一般不会产生任何危害。 
僵尸进程 僵尸进程是指一个进程使用 fork() 函数创建子进程，如果子进程退出，而父进程并没有调用 wt() 或者wtpid() 系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。 
解决僵尸进程 一般，为了防止产生僵尸进程，在 fork() 子进程之后我们都要及时在父进程中使用 wt() 或者 wtpid() 系统调用，等子进程结束后，父进程回收子进程 PCB 的资源。 同时，当子进程退出的时候，内核都会给父进程一个 SIGCHLD 信号，所以可以建立一个捕获 SIGCHLD 信号的信号处理函数，在函数体中调用 wt() 或 wtpid()，就可以清理退出的子进程以达到防止僵尸进程的目的。


9.静态库和动态库的区别？

静态库和动态库的区别： 
1. 命令方式不同 
- 静态库命名 Linux : libxxx.a lib : 前缀（固定） xxx : 库的名字，自己起 .a : 后缀（固定） Windows : libxxx.lib 
- 动态库命名 Linux : libxxx.so lib : 前缀（固定） xxx : 库的名字，自己起 .so : 后缀（固定） Windows : libxxx.dll 
2. 链接时间和方式不同 - 静态库的链接是将整个函数库的所有数据在编译时都整合进了目标代码 - 动态库的链接是程序执行到哪个函数链接哪个函数的库 
静态库和动态库的优缺点： 
1. 静态库优缺点 - 优点：发布程序时无需提供静态库，移植方便，运行速度相对快些 - 缺点：静态链接生成的可执行文件体积较大，消耗内存，如果所使用的静态库发生更新改变，程序必须重新编译，更新麻烦。 
2. 动态库优缺点 - 优点：更加节省内存并减少页面交换，动态库改变并不影响使用的程序，动态函数库升级比较方便 - 缺点：发布程序时需要提供动态库

10.虚拟地址如何转换成物理地址？虚拟地址的好处？

内存分段和内存分页。
段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。在段页式系统中，为了实现从逻辑地址到物理地址的转换，系统中需要同时配置段表和页表，利用段表和页表进行从用户地址空间到物理内存空间的映射。
系统为每一个进程建立一张段表，每个分段有一张页表。段表表项中至少包括段号、页表长度和页表始址，页表表项中至少包括页号和块号。在进行地址转换时，首先通过段表查到页表始址，然后通过页表找到页帧号，最终形成物理地址。



来自 <https://www.nowcoder.com/exam/interview/detail?questionClassifyId=0&questionId=2412401&questionJobId=161&type=1> 



虚拟地址的好处：
1. 读写内存的安全性

2,虚拟内存管理最 主要的作用是让每个进程有独立的地址空间 (进程间的安全)

3, VA到PA的映射会给分配和释放内存带来方便

4, 一个系统如果同时运行着很多进程，为各进程分配的内存之和可能会大于实际可用的物理内存，虚拟内存管理使得这种情况下各进程仍然能够正常运行

来自 <https://blog.csdn.net/liulichao_no1/article/details/17562687> 

11.用户态和内核态的区别，以及如何从用户态变成内核态？
Inter把 C P U 指令集 操作的权限由高到低划为4级：
	ring 0
	ring 1
	ring 2
	ring 3

ring 0被叫做内核态，完全在操作系统内核中运行，访问任意地址的内存
ring 3被叫做用户态，在应用程序中运行，代码没有对硬件的直接控制权限，也不能直接访问地址的内存，程序是通过调用系统接口(System Call APIs)来达到访问硬件和内存



1.操作系统需要两种CPU状态

内核态（Kernel Mode）：运行操作系统程序，操作硬件

用户态（User Mode）：运行用户程序

2.指令划分

特权指令：只能由操作系统使用、用户程序不能使用的指令。 举例：启动I/O 内存清零 修改程序状态字 设置时钟 允许/禁止终端 停机

非特权指令：用户程序可以使用的指令。 举例：控制转移 算数运算 取数指令 访管指令（使用户程序从用户态陷入内核态）

3.特权级别
特权环：R0、R1、R2和R3

R0相当于内核态，R3相当于用户态；

不同级别能够运行不同的指令集合

用户态--->内核态：唯一途径是通过中断、异常、陷入机制（访管指令）
内核态--->用户态：设置程序状态字PSW

来自 <https://www.cnblogs.com/gizing/p/10925286.html> 







12.说一说epoll的原理
标准回答 epoll 是一种更加高效的 IO 复用技术，epoll 的使用步骤及原理如下： 
1. 调用 epoll_create() 会在内核中创建一个epoll_event 结构体数据，称之为 epoll 对象，在这个结构体中有 2 个比较重要的数据成员，一个是需要检测的文件描述符的信息 （红黑树），还有一个是就绪列表，存放检测到数据发生改变的文件描述符信息（双向链表）；
 2. 调用 epoll_ctrl() 可以向 epoll 对象中添加、删除、修改要监听的文件描述符及事件； 
3. 调用 epoll_wt() 可以让内核去检测就绪的事件，并将就绪的事件放到就绪列表中并返回，通过返回的事件做进一步的事件处理。
 
epoll 的两种工作模式：
 
LT水平触发模式

epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。

当下一次调用epoll_wait时，epoll_wait还会再次向应用程序报告此事件，直至被处理。支持Block和Non Block 
Socket 连接。

ET边缘触发模式

epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件

必须要一次性将数据读取完，使用非阻塞I/O，读取到出现eagain

13.select，poll,epoll有哪些区别？

select/poll/epoll
	- 调用函数

select和poll都是一个函数，epoll是一组函数

	- 文件描述符数量

select通过线性表描述文件描述符集合，文件描述符有上限，一般是1024，但可以修改源码，重新编译内核，不推荐

poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目

epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效

将文件描述符从用户传给内核

	- select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝

epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上

内核判断就绪的文件描述符

	- select和poll通过遍历文件描述符集合，判断哪个文件描述符上有事件发生

epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。

epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list

	- 应用程序索引就绪文件描述符

select/poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历

epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可

工作模式

select和poll都只能工作在相对低效的LT模式下

epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。 

应用场景

当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如select和poll

当监测的fd数目较小，且各个fd都比较活跃，建议使用select或者poll

当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能

ET、LT、EPOLLONESHOT
LT水平触发模式

epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。

当下一次调用epoll_wait时，epoll_wait还会再次向应用程序报告此事件，直至被处理

ET边缘触发模式

epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件

必须要一次性将数据读取完，使用非阻塞I/O，读取到出现eagain

EPOLLONESHOT

一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket

我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件


14.临界区和互斥锁的区别
1、临界区只能用于对象在同一进程里线程间的互斥访问；互斥体可以用于对象进程间或线程间的互斥访问。
2、临界区是非内核对象，只在用户态进行锁操作，速度快；互斥体是内核对象，在核心态进行锁操作，速度慢。
3、临界区和互斥体在Windows平台都下可用；Linux下只有互斥体可用


15.什么是互斥锁和自旋锁？互斥锁和自旋锁有什么区别？
互斥锁和自旋锁对于加锁失败后的处理方式是不一样的
	- 互斥锁加锁失败后，线程会释放CPU，给其他线程。互斥锁加锁失败后而阻塞的现象是由操作系统内核实现的。互斥锁加锁失败后，会从用户态陷入内核态，这样会有两次线程上下文切换的成本。如果被锁住的代码执行时间很短，就不应该使用互斥锁，而应该使用自旋锁，否则使用互斥锁。
	- 自旋锁加锁失败后，线程会忙等待，直到它拿到锁。

	16. 什么是读写锁？
	读写锁适用于能明确区分读操作和写操作的场景。
	读写锁的工作原理是：
		• 当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。
		• 但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。
	
	• 读写锁在读多写少的场景下，能够发挥出优势。


	
	17. 乐观锁和悲观锁
	前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。
	悲观锁做事比较悲观，它认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。
	乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。
	乐观锁全程并没有加锁，所以它也叫无锁编程。
	
	多人同时编辑文档用的就是乐观锁。
	
	
	18. 详细介绍线程、进程和协程？
	
	
	• 进程是资源分配最小单元。进程拥有完整的虚拟地址空间，当发生进程切换时，不同的进程拥有不同的虚拟地址空间。而同一进程的多个线程共享同一地址空间（不同进程之间的线程无法共享）
	• 线程是CPU调度的最小单元，一个进程包含若干线程（至少一个线程）。
	• 线程比进程小，基本上不拥有系统资源。线程的创建和销毁所需要的时间比进程小很多
	• 由于线程之间能够共享地址空间，因此，需要考虑同步和互斥操作
	• 一个线程的意外终止会影响整个进程的正常运行，但是一个进程的意外终止不会影响其他的进程的运行。因此，多进程程序安全性更高。
	
	协程（Coroutine，又称微线程）是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制。
	• 协程可以比作子程序，但执行过程中，子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来继续执行。协程之间的切换不需要涉及任何系统调用或任何阻塞调用
	• 协程只在一个线程中执行，是子程序之间的切换，发生在用户态上。而且，线程的阻塞状态是由操作系统内核来完成，发生在内核态上，因此协程相比线程节省了线程创建和切换的开销
	• 协程中不存在同时写变量冲突，因此，也就不需要维护线程同步的互斥锁、信号量等
	

	
	
	
	
	 
	
	
