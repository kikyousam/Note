# 计网
### 1. TLS四次握手？
- 客户端发出请求（ClientHello）
首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。
在这一步，客户端主要向服务器提供以下信息。
    - 支持的协议版本，比如TLS 1.0版。
    - 一个客户端生成的随机数，稍后用于生成"对话密钥"。
    - 支持的加密方法，比如RSA公钥加密。
    - 支持的压缩方法。
- 服务器回应（SeverHello）
    - 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
    - 确认使用的加密方法，比如RSA公钥加密，返回加密公钥
    - 服务器证书
- 客户端回应
    -验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。
    - 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。
    - 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。
- 服务器
    - 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。
    - 使用密码加密一段握手消息，发送给浏览器。

### 2. TCP Keep_alive长连接机制？
TCP长连接下，若长时间客户端和服务器没有数据往来，可能是其中一方断开了连接，而其中另一方一直维持长连接，会造成系统资源的浪费以及可能导致下一次连接出错。Keep alive机制是指，当长时间没有数据往来时，其中维持连接的一方会发送一个探测包，如连接仍正常，仍需维持连接。


### 3.键入网址到网页显示，期间发生了什么？

向浏览器输入url地址
DNS 解析:将域名解析成 IP 地址
TCP 连接：TCP 三次握手
发送 HTTP 请求
服务器处理请求并返回 HTTP 报文
浏览器解析渲染页面
断开连接：TCP 四次挥手
解题思路
得分点
DNS解析、TCP握手、HTTP缓存、重定向、服务器状态码、渲染引擎和JS引擎互斥、渲染过程、浏览器进程、网络进程、渲染进程
标准回答
输入地址，浏览器查找域名的 IP 地址。
浏览器向 该 IP 地址的web 服务器发送一个 HTTP 请求，在发送请求之前浏览器和服务器建立TCP的三次握手，判断是否是HTTP缓存，如果是强制缓存且在有效期内，不再向服务器发请求，如果是HTTP协商缓存向后端发送请求且和后端服务器对比，在有效期内，服务器返回304，直接从浏览器获取数据，如果不在有效期内服务器返回200，返回新数据。
请求发送出去服务器返回重定向，浏览器再按照重定向的地址重新发送请求。
如果请求的参数有问题，服务器端返回404，如果服务器端挂了返回500。
如果有数据一切正常，当浏览器拿到服务器的数据之后，开始渲染页面同时获取HTML页面中图片、音频、视频、CSS、JS，在这期间获取到JS文件之后，会直接执行JS代码，阻塞浏览器渲染，因为渲染引擎和JS引擎互斥，不能同时工作，所以通常把Script标签放在body标签的底部。
渲染过程就是先将HTML转换成dom树，再将CSS样式转换成stylesheet，根据dom树和stylesheet创建布局树，对布局树进行分层，为每个图层生成绘制列表，再将图层分成图块，紧接着光栅化将图块转换成位图，最后合成绘制生成页面。


### 4.简述 HTTP 和 HTTPS 的区别？

1. HTTP：超文本传输协议，是互联网上应用最为广泛的一种网络协议
  HTTPS：简单讲是HTTP的安全版，即HTTP下加入SSL层、HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

2. HTTP与HTTPS的区别 　　

1.HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL 安全协议，使得报文能够加密传输。（简介）
2.HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL的握手过程，才可进入加密报文传输。（连接建立）
3、HTTP 的端口号是 80，HTTPS 的端口号是 443。（端口号）
4.HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。（认证）
（1）HTTPS是密文传输，HTTP是明文传输；

（2）默认连接的端口号是不同的，HTTPS是443端口，而HTTP是80端口；

（3）HTTPS请求的过程需要CA证书要验证身份以保证客户端请求到服务器端之后，传回的响应是来自于服务器端，而HTTP则不需要CA证书；

（4）HTTPS=HTTP+加密+认证+完整性保护。




### 5. HTTP常见状态码


1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。
2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。
	• 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。
	• 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
	• 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
	• 
4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。
	• 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。
	• 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。
	• 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。
	• 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
	
	• 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
	• 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。


### 6.请你所说TCP、UDP的区别？
1.TCP是面向对象连接；而UDP是无面向对象连接
2.TCP确保所传输的数据一定会到达目的地，但时间却不能保证；而UDP不确保数据会按原来顺序到达，但具有实时性
3.TCP的使用场景是不在意传输数据速度，但在意传输数据准确；而UDP的使用场景则是对实时性要求较高 
4.TCP的首部开销大，占用20字节；而UDP的首部开销小，只占用8个字节 
5.TCP只支持点对点的数据传输；而UDP支持一对一、一对多、多对多等各种场景 
6.TCP有拥塞控制和流量控制来确保数据的安全性，但如果网络拥塞的话，速度会比较慢；UDP即使在网络拥塞的时候，传输速度也不会慢


### 7.请你说说 TCP 三次握手四次挥手过程
三次握手过程：
第一次握手：客户端向服务器端发送一个特殊的TCP报文。该报文不包含应用层数据。但是在报文段的首部的SYN标志位会被置为1.客户端会随机选择一个初始序号x，将此x设置为为该报文段的序号。
第二次握手：当服务器收到这个特殊的TCP报文后，为TCP连接分配缓存和变量，并向客户TCP发送允许连接的报文段。该报文段也不包含应用层数据。SYN标志位被置为1，确认号字段置为x+1,服务器同样随机选择一个初始序号y。
第三次握手：客户端收到服务器发送的特殊报文段后，客户端也要为TCP连接分配缓存和变量。客户则向服务器发送另一个报文段。因为连接已经建立，SYN标志位置为1，确认号字段置为y+1,初始序号为x+1.
首先第一次挥手：客户应用进程发送关闭连接命令。客户TCP向服务器进程发送一个终止报文段。其首部FIN标志位置为1
第二次挥手：服务器收到该报文段后，就回送一个确认报文段，ACK比特置为1.
第三次挥手：服务器发送自己的终止报文段，FIN比特置1
第四次挥手：客户端对终止报文段回送一个确认报文段

以下是客户端向服务器端发起TCP连接的详细过程： 1. 客户端和服务器端刚开始都是处于CLOSED（关闭）状态。 2. 要注意的是客户端主动打开连接，而服务器端是被动打开连接的。 3. 服务器端的进程先创建TCB（传输控制块）准备接受客户端的连接请求。 4. 客户端的进程也是先创建TCB（传输控制块），然后向服务器端发出连接请求报文段，这个报文段中的同步位SYN置为1，同时选择一个初始序号seq=x。TCP协议规定了SYN=1的报文段不可以携带数据，但是要消耗掉一个序号。这个时候客户端进入SYN-SENT状态。 5. 服务器端收到连接请求报文之后，如果同意连接，就给客户端发送确认响应。在确认报文中应该将同步位SYN和ACK都置为1，而确认号是ACK+1。这时候服务器端也需要给自己选一个初始序号seq=y。值得注意的是这个确认报文也不能携带数据，同样要消耗掉一个序号。这时服务器端进入SYN-RECEIVED状态。 6. 客户端进程收到服务器端的确认报文，最后还要向服务器端给出确认。确认报文段的ACK置为1，确认号是y+1，而自己的序号seq=x+1。TCP标准规定，ACK报文段可以携带数据，但是如果不携带数据就不消耗序号。在这个情况下，下一个数据报文的序号仍然是seq=x+1。到这时，TCP连接已经成功建立，A进入ESTABLISHED（已建立连接）状态。 
到此TCP连接三次握手的过程就全部结束了。但是为什么一定要三次握手而不是两次，为什么客户端最后还需要发送一次确认报文呢？
其实主要是为了防止已经失效的连接请求报文突然又被传送给了服务器端，然后产生错误。假设现在有一种情况，客户端发出的第一个连接请求报文段并没有丢失而是在某些网络节点上被滞留了，直到客户端和服务器端的新连接已经释放后的某个时间点，第一个连接请求报文段才到了服务器端，这时候服务器端以为客户端又发起了一次请求，于是服务器端向客户端发起了确认连接报文段，同意连接。假设不采用三次握手，这时候连接已经建立了，但是客户端并不知道这个情况，服务器端会一直等待客户端的数据报文，这样服务器端的资源就会被浪费，占用大量的资源。所以采用三次握手可以防止这种现象，保护网络和系统资源。 
TCP连接释放的过程比较复杂，客户端和服务器端都可以主动释放连接。下面是从客户端主动释放连接为例讲解四次挥手的详细过程： 1. 客户端的应用进程先向TCP发出一个连接释放报文段，然后停止发送数据报，主动关闭TCP连接。客户端需要将连接释放报文段首部的终止控制FIN置为1，序号设置为u，u相当于前面传输的数据报文段的最后一个字节的序号加1。这时候客户端进入FIN-WT-1（终止等待1）状态，等待服务器端的确认。需要注意的是，FIN报文段也是即使不携带数据，它也消耗一个序号。 2. 服务器在收到客户端发来的连接释放报文段请求之后就发出确认，确认号ack=u+1，这个报文段自己的序号是v，v相当于之前已经传送出去的最后一个报文段的序号加1。这时候服务器端进入CLOSE-WT（关闭等待）状态，这时候服务器端的TCP进程就要通知应用进程，客户端到服务器端的连接已经关闭了。需要注意的是，这个时候的TCP连接就处于一个半关闭（half-colse）的状态，尽管客户端已经没有数据要发送了，但是服务器端还是可以向客户端发送数据的，服务器端到客户端的连接并没有被释放掉。 3. 如果服务器端也没有数据要发送给客户端了，那么应用进程就通知TCP释放连接。这时候服务器端发出的连接释放报文段请求的终止指令FIN也置为1。这时候服务器端的序号已经是w了，因为在半关闭状态服务器端可能又发送了一些数据，服务器也必须重复上次已经发送过的确认号ack=u+1。这时候服务器端进入LAST-ACK（最后确认）状态，等待客户端的确认。 4. 客户端收到服务器端的连接释放请求报文段之后，必须发出确认。在确认报文段中把ACK置为1，确认号ack=w+1，而自己的序号是seq=u+1（根据TCP标准，FIN消耗了一个序号），然后进入TIME-WT（时间等待）状态，这时候连接并没有释放掉，必须等到2倍的MSL（最长报文段寿命）之后，连接才会释放。

### 8.get和post的区别？

GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。

POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。

### 9.TCP如何实现可靠传输？

- 序列号：TCP给发送的每一个包都进行编号，来保证发送的数据包能有序唯一的到达接收端。 
- 检验和：TCP将保持它首部和数据段的检验和。用来检测数据在传输过程中是否发生了变化。 
- 确认应答：如果收到的数据报报文段的检验和没有差错，就确认收到，如果有差错，TCP就丢弃这个报文段。
- 停止等待协议：它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 
- 超时重传：当 TCP 发出一个数据报后，发送方启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
- 流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 
- 拥塞控制：当网络拥塞时，减少数据的发送。 

### 10.请你说说 TIME_WT状态

TCP四次挥手结束时，主动发起连接释放请求的一方进入TIME_WT状态，然后等待2MSL（最大报文生存期）才会回到CLOSED初始状态。 
产生TIME_WT的原因主要是为了实现TCP全双工连接的可靠释放，当主动发起连接释放请求的一方最后发送ACK确认数据包在网络中丢失时，由于TCP的重传机制，被动关闭的一方会重新发送FIN，在FIN到达主动关闭的一方之前，主动关闭的一方需要维持这条连接，也就是主动的一方TCP资源不可以释放，直到被动关闭一方的FIN到达之后，主动关闭方重新发送ACK确认数据包，经过2MSL时间周期没有再收到被动关闭一方的FIN之后，才会恢复到CLOSED状态，如果没有TIME_WT这个状态，当FIN到达时，主动方会用RST来响应，在被动关闭的一方看来似乎是一个错误，实际上是正常的连接释放过程。

### 11.请你说说拥塞控制机制

拥塞控制就是防止太多的数据进入到网络中，这样可以使网络中的路由器或者链路不会过载，拥塞控制的算法有以下四种：慢启动、拥塞避免、快重传、快恢复。
慢启动（slow-start）：当客户端发送数据的时候，如果一次性把大量的数据字节发送到网络中，就有可能引起网络拥塞，因为并不清楚网络的负荷状态。所以较好的方法是先探测一下，由小到大逐渐增大发送窗口，也就是慢慢地增大窗口数值。通常刚开始发送报文段时先把拥塞窗口cwnd设置为一个最大报文段MSS的值，每收到一对新的报文段确认后，把拥塞窗口的数值再加一个MSS。 
拥塞避免（congestion avoidance）：让拥塞窗口cwnd缓缓地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，让拥塞窗口按照线性规律慢慢增长，比慢启动算法的拥塞窗口增长速率慢很多。 
快重传（fast retransmit）：要求接收方每收到一个失序的报文段之后就立即发出重复确认而不是等待自己发送数据时捎带确认，为的就是让发送方能尽早地知道有报文段没有到达接收方。 
快恢复（fast recovery）：两个要点，一是当发送方连续收到三个重复确认时，就执行”乘法减小“算法，把慢开始门限ssthresh减半，这是为了预防网络发生拥塞。二是发送方认为网络很可能没有发生阻塞，因此不会执行慢开始算法，而是把cwnd值设置成慢开始门限ssthresh减半之后的数值，然后执行拥塞避免算法，使拥塞窗口呈线性增长。

### 12.请你说说TCP/IP 5层协议

1. 应用层：应用层是体系结构中的最高层，定义了应用进程间通信和交互的规则。应用层协议较多，如万维网应用的HTTP协议、电子邮件的SMTP协议、文件传送的DTP协议等。应用层交互的数据称为报文 协议：HTTP、HTTPS、FTP、TFTP、SMTP等 
2. 运输层：运输层的任务是负责向两个计算机中进程之间的通信提供一种通用的数据传输服务，应用层通过运输层可以传输报文。通用是指不会针对特定的应用层协议进行详细的划分，多种应用层协议公用同一个运输层服务，所以运输层有复用的功能。当然也有分发的功能，指将接受到的信息分别交付到应用层不同的进程中。 协议：UDP、TCP 
3. 网络层：网络层的任务是负责为网络上不同的主机提供通信服务。在发送数据时，网络层将运输层产生的报文段或者用户数据报封装成分组或者包（packet）进行传送。由于网络层使用IP协议，所以分组或包（packet）也叫IP数据报，简称数据报。网络层还需要寻找合适的路由路线，让源主机运输层发送下来的数据报能通过路由器找到目的主机。 协议：ICMP、IGMP、IP（IPv4、IPv6）、ARP、RARP 
4. 数据链路层：数据链路层简称链路层。两个节点传输数据时，链路层将网络层交下来的数据报组装成帧，在链路上传送帧。每一帧都包括数据和控制信息（同步信息、地址信息、差错控制等）。 
5. 物理层：物理层上数据的单位是Bit比特，数据的传输都是通过0（或1）比特流来实现的，而0（或1）比特流与电压的高低有关。物理层中比特流的传输不再加控制信息，需要注意的是比特流应从首部开始传送。

### 13.请你说说TCP粘包

若发送方发送数据包的长度和接收方在缓存中读取的数据包长度不一致，就会发生粘包，发送端可能堆积了两次数据，每次100字节一共在发送缓存堆积了200字节的数据，而接收方在接收缓存中一次读取120字节的数据，这时候接收端读取的数据中就包括了下一个报文段的头部，造成了粘包

### 14.TCP和UDP的使用场景

 UDP：语音、视频、寻址、游戏、广播。TCP：邮件、远程登陆、超文本、文件、身份信息、重要内容 标准回答 UDP的优点是快，没有TCP各种机制，少了很多首部信息和重复确认的过程，节省了大量的网络资源。缺点是不可靠不稳定，只管数据的发送不管过程和结果，网络不好的时候很容易造成数据丢失。又因为网络不好的时候不会影响到主机数据报的发送速率，这对很多实时的应用程序很重要，因为像语音通话、视频会议等要求源主机要以恒定的速率发送数据报，允许网络不好的时候丢失一些数据，但不允许太大的延迟。DNS和ARP协议也是基于UDP实现的，要求快速获取IP、MAC地址，如果基于TCP那么对整个因特网的资源占用过大且速度慢。还有游戏应用程序也是通过UDP来传输报文段，允许出现丢帧导致的卡顿，但是对游戏的整体体验不会产生严重的影响。所以UDP在语音、视频、寻址、游戏、广播方面有很好的应用前景，实时性高，允许部分的数据丢失。 TCP的优点是面向连接提供可靠交付，即对数据有保证、无差错的进行运输。当需要数据准确无误的运输给对方时，如浏览器中需要获取服务器资源使用的HTTP/HTTPS协议，需要保证文件准确、无差错，邮件服务器中使用的SMTP协议，保证邮件内容准确无误的传递给对方，或者是大型应用程序文件，这些都要保证文件的准确、无差错的运输给对方，所以一定要基于TCP来运输，而不是UDP。 加分回答 UDP的应用场景是根据它的部分特性决定的，如下： - 面向无连接 - 尽最大努力交付 - 面向报文 - 一对多 TCP的应用场景是根据它的部分特性决定的，如下： - 面向连接 - 单播，一对一 - 可靠交付（确认机制、重传机制、流量控制、拥塞控制等）

### 15.DNS解析过程和DNS劫持

标准回答 DNS查询的过程简单描述就是：主机向本地域名服务器发起某个域名的DNS查询请求，如果本地域名服务器查询到对应IP，就返回结果，否则本地域名服务器直接向根域名服务器发起DNS查询请求，要么返回结果，要么告诉本地域名服务器下一次的请求服务器IP地址，下一次的请求服务器可能是顶级域名服务器也可能还是根域名服务器，然后继续查询。循环这样的步骤直到查询到结果，本地域名服务器拿到结果返回给主机。 在完成整个域名解析的过程之后，并没有收到本该收到的IP地址，而是接收到了一个错误的IP地址。比如输入的网址是百度，但是却进入了奇怪的网址，并且地址栏依旧是百度。在这个过程中，攻击者一般是修改了本地路由器的DNS地址，从而访问了一个伪造的DNS服务器，这个伪造的服务器解析域名的时候返回了一个攻击者精心设计的网站，这个网站可能和目标网站一模一样，当用户输入个人账户时，数据会发送给攻击者，从而造成个人财产的丢失。 

### 16.IP协议的首部结构

4 4 8     16            4版本号  4首部长度  8服务类型    16总长度
16         3  13        16标识位    3标志位  13片偏移
8  8      16             8生存时间  8协议    16首部校验和
32                         32源ip地址
32                         32目的ip地址


### 17.请你说说ARP协议，协议是怎么实现的，是怎么找到MAC地址的

ARP提供了将IP地址转换为链路层地址的机制，而且只为在同一个子网上的主机和路由器接口解析IP地址。 ARP寻址的具体过程如下： 1. 发送数据到子网中，每台主机都有一个IP对应MAC地址的映射表，每个映射都有一个TTL值，即寿命。 2. 主机发送一个数据报，该数据报要IP寻址到本子网上另一台主机或路由器。发送主机需要获得给定IP地址的目的主机的MAC地址。如果发送方的ARP表具有该目的结点的表现，这个任务是很容易完成的。如果ARP表中当前没有该目的主机的表项，在这种情况下，发送方用ARP协议来解析这个地址。首先，发送方构造一个称为ARP分组（ARP packet）的特殊分组。一个ARP分组有几个字段，包括发送和接收IP地址及MAC地址。ARP查询分组和响应分组都具有相同的格式。ARP查询分组的目的是询问子网上所有其他主机和路由器，以确定对应于要解析的IP地址的那个MAC地址。 3. 主机向它的适配器传递一个ARP查询分组，并且指示适配器应该用MAC广播地址（即FF-FF-FF-FF-FF-FF）来发送这个分组。适配器在链路层帧中封装这个ARP分组，用广播地址作为帧的目的地址，并将该帧传输进子网中。包含该ARP查询的帧能被子网上的所有其他适配器接收到，并且（由于广播地址）每个适配器都把在该帧中的ARP分组向上传递给ARP模块。这些ARP模块中的每个都检查它的IP地址是否与ARP分组中的目的IP地址相匹配。与之匹配的一个给查询主机发送回一个带有所希望映射的响应ARP分组。然后查询主机能够更新它的ARP表，并发送它的IP数据报，该数据报封装在一个链路层帧中，并且该帧的目的MAC就是对先前ARP请求进行响应的主机或路由器的MAC地址。 

### 18.说说close_wt状态

TCP四次挥手时，对于服务端来说，客户端先发送断开请求，服务端给予回应，此时服务端进入CLOSE_WAIT状态，此时服务端知道客户端的请求结束了，但是服务端如果还有数据发送，依然可以发送给客户端，因为TCP连接是全双工的

### 19.对称加密和非对称加密

对称加密: 加密和解密的秘钥使用的是同一个.

缺点：
在数据传送前，发送方和接收方必须商定好秘钥，然后 使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担

非对称加密: 与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（public key）和私有密钥（private key）。

### 20. 请你说说HTTPS

HTTPS的特点：
 1. 内容加密：混合加密方式，对称加密和非对称加密。
 2. 验证身份：通过数字证书认证客户端访问的是正确的服务器。 
1. 数据完整性：数字签名算法防止传输的数据被中间人篡改。


### 21. 请你说说TCP超时重传机制，时间是多少
 
TCP可靠性中最重要的一个机制是处理数据超时和重传。TCP协议要求在发送端每发送一个报文段，就启动一个定时器并等待确认信息。接收端成功接收新数据后返回确认信息。若在定时器超时前数据未能被确认，TCP就认为报文段中的数据已丢失或损坏，需要对报文段中的数据重新组织和重传。 影响超时重传机制协议效率的一个关键参数是重传超时时间（RTO）。
当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；
当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。

### 22. UDP 怎么样可以实现可靠的传输？

如果想要使用UDP还要保证数据的可靠传输，就只能通过应用层来做文章。
应用层角度考虑分别是：
 1. 提供超时重传机制，能避免数据报丢失的问题。 
2. 提供确认序列号，保证数据拼接时候的正确排序。 

### 23. HTTPS加解密过程是怎么实现的？

HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输。总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。 在整个HTTPS数据传输的过程中一共会涉及到四个密钥： 
1. CA机构的公钥，用来验证数字证书是否可信任 
2. 服务器端的公钥 
3. 服务器端的私钥 
4. 客户端生成的随机密钥
 一个HTTPS请求可以分为两个阶段，证书认证阶段和数据传送阶段。又可以细分为六个步骤： 
1.客户端想服务器发起HTTPS的请求，连接到服务器的443端口；

2.服务器将非对称加密的公钥和证书传递给客户端

3.客户端接受到该公钥进行验证，就是验证证书，如果有问题，则HTTPS请求无法继续；如果没有问题，则上述公钥是合格的。（第一次HTTP请求）客户端这个时候随机生成一个私钥，成为client key,客户端私钥，用于对称加密数据的。使用前面的公钥对client key进行非对称加密；

4.进行二次HTTP请求，将加密之后的client key传递给服务器；

5.服务器使用私钥进行解密，得到client key,使用client key对数据进行对称加密

6.将对称加密的数据传递给客户端，客户端用其client key解密，得到服务器发送的数据，完成第二次HTTP请求。




### 24. 请你说说 HTTP1.x 和 HTTP2.0 的区别是什么？


二进制、多路复用、头部压缩、服务器推送。
 标准回答 HTTP1.x和HTTP2.0主要的区别主要HTTP2.0使用了二进制的数据传输方式、多路复用机制、头部缓存和服务器推送特点。 
加分回答 HTTP1.x和HTTP2.0主要的区别主要有以下四点： - 二进制格式（Binary Format）：HTTP1.x的解析是基于文本，但是基于文本协议的格式解析存在天然缺陷。文本的表现形式应该具有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 - 多路复用（MultiPlexing）：连接共享，每一个请求都是是用作连接共享机制的。一个请求对应一个id，这样一个连接上可以有多个请求，每个连接的请求可以随机的混杂在一起，接收方可以根据请求的 id将请求再归属到各自不同的服务端请求里面。 - 头部压缩：HTTP1.x的头部带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的头部大小，通讯双方各自缓存一份头部表，既避免了重复头部的传输，又减小了需要传输的大小。 - 服务端推送（server push）：如果请求了index.html文件，服务器端会主动将它的依赖文件一起返回。

### 25. 怎么理解字节流和数据报的概念？

数据报是网络传输的数据的基本单元，包含一个报头和数据本身，其中报头描述了数据的目的地以及和其它数据之间的关系。同一报文的不同分组可以由不同的传输路径通过通信子网。UDP基于数据报。

字节流方式 消息可能会被操作系统分成多个的 TCP 报文 指的是仅把传输中的报文看作是一个字节序列，在字节流服务中，由于没有报文边界，用户进程在某一时刻可以读或写任意数量的字节。 TCP基于字节流。

### 26.说一说滑动窗口？
滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。
TCP的滑动窗口解决了端到端的流量控制问题，允许接受方对传输进行限制，直到它拥有足够的缓冲空间来容纳更多的数据。

### 27. 计算机网络七层协议有哪些？各自作用？
应用层，管理应用进程间的通信规则。
表示层，对数据进行处理。
会话层，用来管理进程。
传输层，提供数据的传输服务。
网络层，进行逻辑地址的查询。
数据链路层，建立节点的连接和信息校验。
物理层，负责最底层的数据传输。


### 28. TCP三次握手中的半连接队列和全连接队列

在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：
	半连接队列，也称 SYN 队列；
	全连接队列，也称 accept 队列；
服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。


来自 <https://blog.csdn.net/weixin_44844089/article/details/115740686> 

### 29. DDos是什么?SYN FLOOD怎么处理？
DDoS全称Distributed Denial of Service，意思为“分布式拒绝服务”，即利用大量合法的分布式服务器对目标发送请求，从而导致正常合法用户无法获得服务。

打个比方：某商店生意异常火爆，引起了其他商户的不满，于是商户们找了百来号人去他店里，看商品、问价格，但却不掏钱购买。该商家看似忙了一天，其实一件也没卖出去。同时，真正想要买东西的顾客也没得到接待，因为店里挤得进不去。

通过发送伪造源IP的TCP数据包发送SYN或ACK包、发送包含错误设置的地址值等攻击方式，耗尽服务器资源，导致服务器拒绝访问。

SYN Flood是互联网上最原始、最经典的DDoS（Distributed Denial of Service）攻击之一。它利用了TCP协议的三次握手机制，攻击者通常利用工具或者控制僵尸主机向服务器发送海量的变源IP地址或变源端口的TCP SYN报文，服务器响应了这些报文后就会生成大量的半连接，当系统资源被耗尽后，服务器将无法提供正常的服务。

### 30. 为什么要有time wait?time wait过多怎么办？
TIME-WAIT 作用是等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。

过多的 TIME-WAIT 状态主要的危害有两种：
	• 第一是内存资源占用；
	• 第二是对端口资源的占用，一个 TCP 连接至少消耗「发起连接方」的一个本地端口；














