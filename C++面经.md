# c++相关问题
## 什么是RAII?
---

**面试回答示例：**

“RAII，全称是**Resource Acquisition Is Initialization**，翻译为‘资源获取即初始化’。它是C++中一种**核心的编程范式**和**资源管理理念**，其核心思想是将**资源的生命周期**与**对象的生命周期**严格绑定在一起。”

“具体来说，RAII机制的工作原理是：”

1.  **资源获取在构造函数中完成：** 当一个对象被创建（初始化）时，在其**构造函数**中获取所需的资源（如动态内存、文件句柄、网络连接、数据库连接、互斥锁等）。
2.  **资源释放在析构函数中完成：** 当对象的生命周期结束（例如离开作用域、被`delete`或容器被销毁）时，编译器会自动调用其**析构函数**，在析构函数中释放该对象所持有的资源。
3.  **所有权与责任绑定：** 对象是其所管理资源的唯一拥有者（Owner），并承担释放资源的责任。资源的所有权通常不允许复制（通过禁用拷贝构造/赋值），或者通过移动语义进行安全转移。

---

> 最终更新于 2025-03-21 16:52:03
## 智能指针
1. unique_ptr的独占所有权？怎么转移unique_ptr的所有权？
    unique_ptr对象始终是关联的原始指针的唯一所有者。我们无法复制unique_ptr对象，它只能移动。
    由于每个unique_ptr对象都是原始指针的唯一所有者，因此在其析构函数中它直接删除关联的指针，不需要任何参考计数。
    std::move() 将把 待转换的智能指针 转换为一个右值引用。因此，调用 unique_ptr 的移动构造函数，并将关联的原始指针传输到 新的智能指针。在转移完原始指针的所有权后， 待转换的智能指针将变为空。
2. b = a; 怎么实现？b = move(a); 怎么实现？及两者的区别？
    b = a, 是通过拷贝赋值函数实现。首先检查是否是自赋值，不是自赋值的话，将a里的成员变量拷贝到b对应的成员变量，成员变量存在指针的话，需要将内存释放掉，再开辟内存进行赋值；
    b = move(a), 是通过移动构造函数实现，同样检查是否是自赋值，不是自赋值的话，将 a的成员变量转移到b对应的成员变量，同时要释放a的成员变量。
    区别：
    (1) 赋值是深拷贝操作，移动是资源转移避免拷贝；
    (2) 源对象状态保持不变，源对象安全可析构，指针指向nullptr;

3. shared_ptr是如何实现共享权的？引用计数和管理的内存地址怎么实现的？是同一块内存空间吗？
   每个 `shared_ptr` 对象内部包含两个指针：  
  - **对象指针**：指向实际管理的堆内存（目标对象）  
  - **控制块指针**：指向动态分配的**控制块**（含引用计数等元数据）
  引用计数（位于控制块中）和管理的内存地址（被管理的对象）在一般情况下（直接使用原始指针构造shared_ptr）是两块独立的内存。


4. shared_ptr的一些函数的实现，unique_ptr的实现？
    可以参考https://github.com/kikyousam/AP1400-2-HW4 的实现。
5. weak_ptr有什么作用？
    weak_ptr的出现是为了解决shared_ptr的循环引用的问题。例如有一个两个节点的双链表，节点分别由两个shared_ptr来实现。这个时候就会出现循环引用的问题，导致删除节点的时候，shared_ptr无法自动析构回收该节点。
    weak_ptr的构造析构不会影响引用计数的大小，当我们采用这种方式时，sp1和sp2的引用计数始终为1，当我们想销毁时就可以随意操作啦！

6. 说说c++ move函数？
    move是转移对象的所有权，所以我们可以move的是可以转移所有权的对象。
    C++，我们可以移动右值，也可以把左值通过std::move变成右值，从而可以实现移动。

7. 说说c++的左值和右值？什么时候用到右值？
    在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。
    C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。

## 虚函数
### 1. 虚函数可以是内联的吗？
    虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。

## 模板
### 1.模板的特化？
一个特定参数集合自定义当前模板，类模板和函数模板都可以全特化。 全特化的模板参数列表应当是空的。


### 1.四大转换cast
#### (1) static_cast
```c++
static_cast<type_id>(expression)
```
该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性
#### (2) const_cast
const_cast可以去除表达式的const的属性
#### （3） dynamic_cast
dynamic_cast 支持运行时识别指针或引用所指向的对象。
#### （4）reinterpret_cast
reinterpret_cast该运算符把expression重新解释成type-id类型的对象。对象在这里的范围包括变量以及实现类的对象。

## 一些函数
### 1. 说一说memcpy和memmove？
memcpy和memmove都是拷贝一定长度内存的接口函数。区别在于：当发生内存冲突（重叠）时，memcpy不能解决这个问题。而memmove不受影响，因为它在这种情况下，会逆序的复制内存中数据。


## STL
### vector的扩容原理？以及vector的push_back的均摊时间复杂度？
该函数首先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器 finish，使 vector变大。如果没有备用空间了，就扩充空间，重新配置、移动数据，释放原空间。​其中​判断是否有备用空间,就是判断 finish是否与 end_of_storage 相等.如果 finish != end_of_storage，说明还有备用空间，否则已无备用空间。
当执行 push_back 操作，该 vector 需要分配更多空间时，它的容量(capacity)会增大到原来的 m 倍。​现在我们来均摊分析方法来计算 push_back 操作的时间复杂度。
![](Pic/2022-07-29-12-02-21.png)
![](Pic/2022-07-29-12-02-50.png)
![](Pic/2022-07-29-12-15-32.png)

## 其他
1. 说说一致性hash?

    https://segmentfault.com/a/1190000021199728.

    服务器节点增加或者减少，使用传统的hash算法会造成节点编号的变化，导致客户端映射到服务器错误。但对于分布式缓存这种的系统而言，映射规则失效就意味着之前缓存的失效，若同一时刻出现大量的缓存失效，则可能会出现 “缓存雪崩”，这将会造成灾难性的后果。将对象和服务器都放置到同一个哈希环后，在哈希环上顺时针查找距离这个对象的 hash 值最近的机器，即是这个对象所属的机器。而使用一致性哈希算法后，这种情况得到了较大的改善，因为只有少部分对象需要重新分配。

2. C++ 的 new 运算符流程?

    1）调用operator new分配内存 ；
    2）调用构造函数生成类对象；
    3）返回相应指针。

3. 什么是栈溢出，什么时候会发生栈溢出？

    栈数据结构满溢，无法存放更多的数据。当出现死循环或者递归调用的过深就会发生栈溢出。函数递归调用时，内核需要在栈中自动保存函数调用时的现场和变量。

4. lambda表达式？
    lambda表达式是c++11的新特性。lambda表达式可以理解为一种匿名函数，可以用来捕获一定范围的变量。
    其有如下形式：
    捕获列表+ 参数列表+ 函数可选项->返回值类型+函数主体。


## 关键字：
1. const关键字
- const可以用来修饰变量，表明该变量是一个常量
- const 可以用来修饰指针，构成指针常量和常量指针
  const T* (const修饰指针，所以是常量指针，指针地址不可以变，指向对象可以变)
  T* const(const 修饰变量，所以是指针常量，常量值不可以变，指针地址可以变)
- const 可以用来修饰引用，表示指向常量的应用。没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰
- 修饰成员函数，说明该成员函数内不能修改成员变量。

2. define和const有什么区别？
   预处理阶段/编译阶段
   无类型安全检查/类型安全检查
   可以取消/不可以取消
   不分配内存/分配内存
   存储在代码段/存储在数据段

3. static 关键字
- 修饰普通变量，修改变量存储区域和生命周期，存储在静态区，在main函数运行前就已经分配了空间。延长变量生命周期至程序结束。（比如说count计数器）
- 修饰普通函数，修改函数的作用域，限制作用域到当前文件（避免不同文件的同名函数，现代cpp常使用匿名空间）
- 修饰类中成员变量，实现类级别的共享数据（单例模式,饿汉式单例模式），**必须在类外单独定义和初始化**
- 修饰类中成员函数，操纵静态成员，不依赖对象实例，没有this指针。


4. inline 关键字
   关于C++内联函数（`inline`），面试官常会从多个角度考察你的理解深度。以下是一些高频问题和考察点，帮助你针对性准备：

     **什么是内联函数？它的目的是什么？**
    *   **期望答案：** 使用 `inline` 关键字建议编译器将该函数调用处用函数体代码替换（类似于宏展开，但更安全）。主要目的是**消除函数调用的开销**（压栈、跳转、返回），提高执行效率，尤其适用于**体积小、被频繁调用**的函数。
    *   **考察点：** 基本概念、设计初衷。

     **内联函数是如何工作的？（与普通函数调用的区别）**
    *   **期望答案：** 编译器在编译阶段，遇到内联函数调用时，会尝试将调用语句替换为该函数体内的实际代码（展开）。而普通函数调用涉及参数压栈、跳转到函数地址执行、执行完返回原调用点、清理栈等步骤。

     **`inline` 关键字是强制性的指令吗？编译器一定会内联它吗？**
    *   **期望答案：** **不是强制指令，只是一个建议（Hint）**。编译器会综合评估是否内联，考虑因素包括：
        *   函数体大小（过大通常不会被内联）
        *   函数复杂度（包含循环、递归、静态变量等可能阻止内联）
        *   调用频率
        *   目标平台特性
        *   编译器的优化设置（如 `-O1`, `-O2`, `-O3`）

    **内联函数与宏（`#define`）有什么区别？为什么说内联函数更好？**
    *   **期望答案：**
        *   **类型安全：** 内联函数是真正的函数，有类型检查；宏是文本替换，无类型检查，容易出错。
        *   **作用域：** 内联函数遵循作用域规则（类作用域、命名空间作用域）；宏是全局的，容易引起命名冲突。
        *   **调试：** 内联函数可以调试（虽然展开后可能有些复杂）；宏在预处理阶段就被替换，调试困难。
        *   **参数求值：** 宏参数可能被多次求值（如 `#define SQUARE(x) ((x)*(x))` 调用 `SQUARE(i++)` 会出问题）；内联函数参数只求值一次。
        *   **可预测性：** 宏的行为有时难以预料；内联函数行为更符合函数语义。















