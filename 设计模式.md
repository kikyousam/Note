https://blog.csdn.net/liang19890820/article/details/66974516
# 设计模式（23）
## 设计模式的类型
- 创建者模式(creational Patterns): 用于创建对象，以便它们可以从实现系统分离出来
- 结构型模式(structural Patterns): 用于不同对象之间形成大型对象结构
- 行为型模式(Behavioral Patterns): 用于管理对象之间的算法、、关系和职责

## 单例模式：
以下是对C++单例模式面试常见问题的完整答案整理，包含概念解释、代码实现和关键要点：

### 一、基础概念与实现
1. **什么是单例模式？核心目的是什么？**  
   - **答案**：确保一个类只有一个实例，并提供全局访问点。核心目的是：
     - 控制资源访问（如配置管理器、线程池）
     - 避免重复创建对象的开销
     - 保证全局状态的一致性

---

### 二、基础实现
2. **手写饿汉式单例**  
```cpp
class Singleton {
private:
    static Singleton instance;  // 静态成员初始化
    Singleton() {}              // 私有构造函数
    
public:
    Singleton(const Singleton&) = delete;             // 禁用拷贝
    Singleton& operator=(const Singleton&) = delete;  // 禁用赋值
    
    static Singleton& getInstance() {
        return instance;
    }
};
// 类外初始化（程序启动时创建）
Singleton Singleton::instance;
```
**特点**：线程安全但可能浪费资源

3. **手写懒汉式单例（C++11线程安全版）**  
```cpp
class Singleton {
private:
    Singleton() {}
    
public:
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
    static Singleton& getInstance() {
        static Singleton instance;  // C++11保证线程安全
        return instance;
    }
};
```
**特点**：按需创建，C++11标准保证静态局部变量线程安全

---
### 总结对比表
| **特性**       | **饿汉式**                          | **懒汉式**                          |
|----------------|------------------------------------|------------------------------------|
| **创建时机**   | 程序启动时                         | 第一次调用`getInstance()`时        |
| **线程安全**   | 天然安全                           | 需额外措施（锁/局部静态变量）      |
| **资源占用**   | 可能浪费（未使用也创建）           | 按需创建，节约资源                 |
| **实现复杂度** | 简单                               | 相对复杂（需处理线程安全）         |
| **首次访问性能** | 无延迟（已创建）                 | 有延迟（需初始化）                 |
| **适用场景**   | 小对象、确定会使用、启动不敏感     | 大对象、可能不使用、内存敏感       |
> 💡 **现代C++推荐**：优先使用**懒汉式（局部静态变量）**，因为C++11标准明确保证其线程安全性，实现简洁且高效。

## 工厂模式：
### C++ 工厂模式面试高频问题及答案整理

---

#### **1. 什么是工厂模式？核心思想是什么？**
**答**：  
工厂模式是一种**创建型设计模式**，将对象的创建逻辑封装在工厂类中，客户端不直接调用构造函数，而是通过工厂接口获取对象实例。  
**核心思想**：  
- **解耦**：分离对象创建与使用逻辑  
- **封装变化**：当创建逻辑变化时，只需修改工厂类  
- **统一入口**：通过统一接口创建多种相关对象  

---

#### **2. 工厂模式的三种类型及区别？**
| **类型**         | **特点**                                                                 | **适用场景**                     |
|------------------|--------------------------------------------------------------------------|----------------------------------|
| **简单工厂**     | 一个工厂类创建所有产品，通过参数区分类型                                 | 产品类型少且固定                 |
| **工厂方法**     | 每个产品对应一个工厂子类，遵循开闭原则                                   | 需要扩展新产品                   |
| **抽象工厂**     | 创建多个产品族的对象（一组相关对象），强调产品间的约束关系               | 需要保证产品兼容性（如UI跨平台） |

---

#### **3. 简单工厂模式示例代码**
```cpp
// 产品基类
class Product {
public:
    virtual void Operation() = 0;
    virtual ~Product() = default;
};

// 具体产品A
class ConcreteProductA : public Product {
public:
    void Operation() override { cout << "Product A\n"; }
};

// 简单工厂
class SimpleFactory {
public:
    static Product* CreateProduct(const string& type) {
        if (type == "A") return new ConcreteProductA();
        if (type == "B") return new ConcreteProductB(); // 扩展新产品需修改此处
        return nullptr;
    }
};

// 客户端
Product* p = SimpleFactory::CreateProduct("A");
p->Operation();
```
**缺点**：违反开闭原则（新增产品需修改工厂类）

---

#### **4. 工厂方法模式如何解决开闭原则问题？**
**答**：  
- 为每个产品定义独立的工厂子类
- 新增产品时只需添加新的工厂类，无需修改已有代码  
**示例**：
```cpp
// 抽象工厂
class Factory {
public:
    virtual Product* CreateProduct() = 0;
};

// 产品A的工厂
class FactoryA : public Factory {
public:
    Product* CreateProduct() override { 
        return new ConcreteProductA(); 
    }
};

// 客户端
Factory* factory = new FactoryA();
Product* p = factory->CreateProduct();
```

---

#### **5. 抽象工厂模式示例（跨平台UI场景）**
```cpp
// 抽象按钮
class Button {
public:
    virtual void Render() = 0;
};
class WinButton : public Button { void Render() override { /* Windows渲染 */ } };
class MacButton : public Button { void Render() override { /* Mac渲染 */ } };

// 抽象工厂
class UIFactory {
public:
    virtual Button* CreateButton() = 0;
    virtual Checkbox* CreateCheckbox() = 0; // 可扩展其他控件
};

// Windows工厂
class WinFactory : public UIFactory {
    Button* CreateButton() override { return new WinButton(); }
    Checkbox* CreateCheckbox() override { return new WinCheckbox(); }
};

// 客户端
UIFactory* factory = new WinFactory(); // 只需切换工厂即可换平台
Button* btn = factory->CreateButton();
btn->Render();
```
**优势**：保证同一工厂创建的所有控件风格一致（如Windows风格按钮+复选框）

---

#### **6. 工厂模式 vs 构造函数？优势？**
**优势**：
1. **命名更清晰**：`CreateLogger()` 比 `new FileLogger(...)` 更表意
2. **封装复杂初始化**：隐藏对象构造的复杂依赖（如配置读取）
3. **控制对象生命周期**：可返回智能指针、对象池复用等
4. **支持多态创建**：运行时动态决定对象类型

---

#### **7. 如何避免工厂返回裸指针导致的内存泄漏？**
**方案**：
```cpp
// 使用智能指针
std::unique_ptr<Product> Factory::CreateProduct() {
    return std::make_unique<ConcreteProductA>();
}

// 客户端
auto product = factory->CreateProduct(); // 自动管理内存
```

---

