# c++相关问题
## 智能指针
1. unique_ptr的独占所有权？怎么转移unique_ptr的所有权？
    unique_ptr对象始终是关联的原始指针的唯一所有者。我们无法复制unique_ptr对象，它只能移动。
    由于每个unique_ptr对象都是原始指针的唯一所有者，因此在其析构函数中它直接删除关联的指针，不需要任何参考计数。
    std::move() 将把 待转换的智能指针 转换为一个右值引用。因此，调用 unique_ptr 的移动构造函数，并将关联的原始指针传输到 新的智能指针。在转移完原始指针的所有权后， 待转换的智能指针将变为空。
2. b = a; 怎么实现？b = move(a); 怎么实现？

    移动构造函数的流程：
    定义一个空的构造函数方法，该方法采用一个对类类型的右值引用作为参数，如以下示例所示：
    ```C++
    //复制
    MemoryBlock(MemoryBlock&& other)
    : _data(nullptr)
    , _length(0)
    {
    }
    ```
    在移动构造函数中，将源对象中的类数据成员添加到要构造的对象：

    ```C++
    复制
    _data = other._data;
    _length = other._length;
    ```
    将源对象的数据成员分配给默认值。 这可以防止析构函数多次释放资源（如内存）:
    ```C++
    复制
    other._data = nullptr;
    other._length = 0;
    ```
    移动复制运算符：
    定义一个空的赋值运算符，该运算符采用一个对类类型的右值引用作为参数并返回一个对类类型的引用，如以下示例所示：
    - 在移动赋值运算符中，如果尝试将对象赋给自身，则添加不执行运算的条件语句。
    - 在条件语句中，从要将其赋值的对象中释放所有资源（如内存）。
    - 执行第一个过程中的步骤 2 和步骤 3 以将数据成员从源对象转移到要构造的对象：
    - 返回对当前对象的引用，如以下示例所示：

3. shared_ptr是如何实现共享权的？引用计数和管理的内存地址怎么实现的？是同一块内存空间吗？
    引用计数。C++ 智能指针底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。引用计数和管理的对象都放在堆空间。

4. shared_ptr的一些函数的实现？
    ``` C++
    5./*移动语义*/
    //移动构造函数
    my_shared_ptr(my_shared_ptr && dying_obj): 
    m_ptr(nullptr),
    m_ref_count(nullptr)
    {
        //初始化后交换指针和引用计数, 等于清除了原shared_ptr的内容
        dying_obj.swap(*this);
    }

    //移动赋值运算符
    my_shared_ptr & operator=(my_shared_ptr && dying_obj)
    {
        //my_shared_ptr(std::move(dying_obj))用移动构造函数创建出一个新的shared_ptr(此时dying_obj的内容被清除了)
        //再和this交换指针和引用计数
        //因为this的内容被交换到了当前的临时创建的my_shared_ptr里，原this指向的引用计数-1
        my_shared_ptr(std::move(dying_obj)).swap(*this);
        return *this;
    }

    void swap(my_shared_ptr & other)
    {
        std::swap(m_ptr, other.m_ptr);
        std::swap(m_ref_count, other.m_ref_count);
    }
    ```
5. weak_ptr有什么作用？

    weak_ptr的出现是为了解决shared_ptr的循环引用的问题。例如有一个两个节点的双链表，节点分别由两个shared_ptr来实现。这个时候就会出现循环引用的问题，导致删除节点的时候，shared_ptr无法自动析构回收该节点。
    weak_ptr的构造析构不会影响引用计数的大小，当我们采用这种方式时，sp1和sp2的引用计数始终为1，当我们想销毁时就可以随意操作啦！

## 虚函数
1. 虚函数可以使内联的吗？

    虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。


## 模板
### 1.模板的特化？
一个特定参数集合自定义当前模板，类模板和函数模板都可以全特化。 全特化的模板参数列表应当是空的。


## 其他
1. 说说一致性hash?

    https://segmentfault.com/a/1190000021199728.

    服务器节点增加或者减少，使用传统的hash算法会造成节点编号的变化，导致客户端映射到服务器错误。但对于分布式缓存这种的系统而言，映射规则失效就意味着之前缓存的失效，若同一时刻出现大量的缓存失效，则可能会出现 “缓存雪崩”，这将会造成灾难性的后果。将对象和服务器都放置到同一个哈希环后，在哈希环上顺时针查找距离这个对象的 hash 值最近的机器，即是这个对象所属的机器。而使用一致性哈希算法后，这种情况得到了较大的改善，因为只有少部分对象需要重新分配。

2. C++ 的 new 运算符流程?

    1）调用operator new分配内存 ；
    2）调用构造函数生成类对象；
    3）返回相应指针。

3. 什么是栈溢出，什么时候会发生栈溢出？

    栈数据结构满溢，无法存放更多的数据。当出现死循环或者递归调用的过深就会发生栈溢出。函数递归调用时，内核需要在栈中自动保存函数调用时的现场和变量。

4. lambda表达式？
    lambda表达式是c++11的新特性。lambda表达式可以理解为一种匿名函数，可以用来捕获一定范围的变量。
    其有如下形式：
    捕获列表+ 参数列表+ 函数可选项->返回值类型+函数主体。



# 操作系统
## 各种锁
### 1. 互斥锁，读写锁，自旋锁的区别
互斥锁和自旋锁的主要区别实在加锁失败的应对上。互斥锁加锁失败会释放CPU，由操作系统进行阻塞，用线程切换来应对。自旋锁加锁失败是通过忙等待来应对。两者没有优劣之分。互斥锁通常用在加锁时间长的代码，用来弥补线程上下文切换的开销。自旋锁常用在加锁时间比较短的代码上。
读写锁
读写锁有三种状态：读加锁状态、写加锁状态和不加锁状态 
只有一个线程可以占有写状态的锁，但可以有多个线程同时占有读状态锁，这也是它可以实现高并发的原因。当其处于写状态锁下，任何想要尝试获得锁的线程都会被阻塞，直到写状态锁被释放；所以读写锁非常适合资源的读操作远多于写操作的情况。
原文链接：https://blog.csdn.net/judgejames/article/details/87286397

### 2. 说说c++ move函数？
move是转移对象的所有权，所以我们可以move的是可以转移所有权的对象。
C++，我们可以移动右值，也可以把左值通过std::move变成右值，从而可以实现移动。

### 3. 说说c++的左值和右值？什么时候用到右值？
在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。
C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。

## 进程 线程 协程
### 1.协程和线程的区别？
协程基于线程，但相对于线程轻量很多，可理解为在用户层模拟线程操作；
每创建一个协程，都有一个内核态线程动态绑定，用户态下实现调度、切换，真正执行任务的还是内核线程。
线程的上下文切换都需要内核参与，而协程的上下文切换，完全由用户去控制，避免了大量的中断参与，减少了线程上下文切换与调度消耗的资源。
线程是操作系统层面的概念，协程是语言层面的概念
线程与协程最大的区别在于：线程是被动挂起恢复，协程是主动挂起恢复
### 2.线程的调度机制
线程的调度是指按照特定的机制为多个线程分配CPU的使用权。 有两种调度模型： 
- 分时调度模型 分时调度模型是让所有线程轮流获得CPU的使用权，并且平均分配每个线程占用的CPU的时间片。
- 抢占式调度模型

### 3.进程间通信
#### 3.1 Linux 下共享内存底层实现原理（不是api）



**进程优先级的字段[ PRI Nice ]CPU调度和进程优先级的关系**

## 内存管理
### 1.虚拟内存和物理内存的差别？
如果使用物理内存的话，有两个缺点。一是运行程序时必须要确保自己程序所用的地址空间没有被其他程序的地址空间占用，这样会非常麻烦。二是如果运行了一个恶意的程序，它可能会修改其他程序的内存空间。造成别的程序崩溃。
虚拟内存的存在就解决了这两个问题。
虚拟地址空间通常被认为是4G的连续内存空间。程序在寻址的时候需要完成从虚拟地址空间向实际物理地址空间的映射转换。这其中用到了页表。虚拟地址空间的优点是：节省了物理空间，提高了物理空间的内存利用率，程序不用担心自己的内存会不会别的内存占用，因为每个进程都有自己独立的虚拟地址空间。

### 2. 进程访问一个地址空间的过程？
每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址
所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上
进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录
页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）
当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常
缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。
原文链接：https://blog.csdn.net/lvyibin890/article/details/82217193

### 3.虚拟内存有哪些？
代码段，未初始化数据段，初始化数据段，堆区，共享区，栈区，操作系统内核。

### 4.虚拟内存的查询流程？
二级页表的查询流程：
**看王道考研补充**

### 5.在不同的进程中创建的malloc返回的内存值是否可能一样？
虽然malloc可能在两个给定的进程中返回相同的值，但这并不重要，因为：
- 在物理上，他们不是同一个地址。
- 进程不会在任何地方共享虚拟内存。
## 其他






# 项目相关问题
### 1. 为什么要用epoll?
因为select存在着很多缺陷，epoLl多路复用技术解决了这些问题。select把监听的文件描述符集合从用户态拷贝到内核态这有很大的开销，epoll没有这个拷贝的开销。内核需要用轮询的方式来查询有事件的文件描述符，效率很低。epoll使用双端队列来存储有事件的文件描述符。select还有文件描述符的上限，select不会告诉你到底是哪几个文件描述符有事件。epoll直接返回有事件发生的描述符，并且知道是有多少个文件描述符有事件发生。

### 2. 为什么epoll的epoll_ctl和epoll_wait分离开？
然而大多数应用场景中，需要监视的socket相对固定，并不需要每次都修改。epoll将这两个操作分开，先用epoll_ctl维护等待队列，再调用epoll_wait阻塞进程。显而易见的，效率就能得到提升。


# 计网
### 1. TLS四次握手？
- 客户端发出请求（ClientHello）
首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。
在这一步，客户端主要向服务器提供以下信息。
    - 支持的协议版本，比如TLS 1.0版。
    - 一个客户端生成的随机数，稍后用于生成"对话密钥"。
    - 支持的加密方法，比如RSA公钥加密。
    - 支持的压缩方法。
- 服务器回应（SeverHello）
    - 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
    - 确认使用的加密方法，比如RSA公钥加密，返回加密公钥
    - 服务器证书
- 客户端回应
    -验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。
    - 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。
    - 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。
- 服务器
    - 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。
    - 使用密码加密一段握手消息，发送给浏览器。

### 2. TCP Keep_alive长连接机制？
TCP长连接下，若长时间客户端和服务器没有数据往来，可能是其中一方断开了连接，而其中另一方一直维持长连接，会造成系统资源的浪费以及可能导致下一次连接出错。Keep alive机制是指，当长时间没有数据往来时，其中维持连接的一方会发送一个探测包，如连接仍正常，仍需维持连接。