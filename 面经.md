# c++相关问题
## 智能指针
1. unique_ptr的独占所有权？怎么转移unique_ptr的所有权？
    unique_ptr对象始终是关联的原始指针的唯一所有者。我们无法复制unique_ptr对象，它只能移动。
    由于每个unique_ptr对象都是原始指针的唯一所有者，因此在其析构函数中它直接删除关联的指针，不需要任何参考计数。
    std::move() 将把 待转换的智能指针 转换为一个右值引用。因此，调用 unique_ptr 的移动构造函数，并将关联的原始指针传输到 新的智能指针。在转移完原始指针的所有权后， 待转换的智能指针将变为空。
2. b = a; 怎么实现？b = move(a); 怎么实现？

    移动构造函数的流程：
    定义一个空的构造函数方法，该方法采用一个对类类型的右值引用作为参数，如以下示例所示：
    ```C++
    //复制
    MemoryBlock(MemoryBlock&& other)
    : _data(nullptr)
    , _length(0)
    {
    }
    ```
    在移动构造函数中，将源对象中的类数据成员添加到要构造的对象：

    ```C++
    复制
    _data = other._data;
    _length = other._length;
    ```
    将源对象的数据成员分配给默认值。 这可以防止析构函数多次释放资源（如内存）:
    ```C++
    复制
    other._data = nullptr;
    other._length = 0;
    ```
    移动复制运算符：
    定义一个空的赋值运算符，该运算符采用一个对类类型的右值引用作为参数并返回一个对类类型的引用，如以下示例所示：
    - 在移动赋值运算符中，如果尝试将对象赋给自身，则添加不执行运算的条件语句。
    - 在条件语句中，从要将其赋值的对象中释放所有资源（如内存）。
    - 执行第一个过程中的步骤 2 和步骤 3 以将数据成员从源对象转移到要构造的对象：
    - 返回对当前对象的引用，如以下示例所示：

3. shared_ptr是如何实现共享权的？引用计数和管理的内存地址怎么实现的？是同一块内存空间吗？
    引用计数。C++ 智能指针底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。引用计数和管理的对象都放在堆空间。

4. shared_ptr的一些函数的实现？
    ``` C++
    5./*移动语义*/
    //移动构造函数
    my_shared_ptr(my_shared_ptr && dying_obj): 
    m_ptr(nullptr),
    m_ref_count(nullptr)
    {
        //初始化后交换指针和引用计数, 等于清除了原shared_ptr的内容
        dying_obj.swap(*this);
    }

    //移动赋值运算符
    my_shared_ptr & operator=(my_shared_ptr && dying_obj)
    {
        //my_shared_ptr(std::move(dying_obj))用移动构造函数创建出一个新的shared_ptr(此时dying_obj的内容被清除了)
        //再和this交换指针和引用计数
        //因为this的内容被交换到了当前的临时创建的my_shared_ptr里，原this指向的引用计数-1
        my_shared_ptr(std::move(dying_obj)).swap(*this);
        return *this;
    }

    void swap(my_shared_ptr & other)
    {
        std::swap(m_ptr, other.m_ptr);
        std::swap(m_ref_count, other.m_ref_count);
    }
    ```

5. 说说一致性hash?

    https://segmentfault.com/a/1190000021199728.

    服务器节点增加或者减少，使用传统的hash算法会造成节点编号的变化，导致客户端映射到服务器错误。但对于分布式缓存这种的系统而言，映射规则失效就意味着之前缓存的失效，若同一时刻出现大量的缓存失效，则可能会出现 “缓存雪崩”，这将会造成灾难性的后果。将对象和服务器都放置到同一个哈希环后，在哈希环上顺时针查找距离这个对象的 hash 值最近的机器，即是这个对象所属的机器。而使用一致性哈希算法后，这种情况得到了较大的改善，因为只有少部分对象需要重新分配。




# 操作系统
## 各种锁
### 1. 互斥锁，读写锁，自旋锁的区别
互斥锁和自旋锁的主要区别实在加锁失败的应对上。互斥锁加锁失败会释放CPU，由操作系统进行阻塞，用线程切换来应对。自旋锁加锁失败是通过忙等待来应对。两者没有优劣之分。互斥锁通常用在加锁时间长的代码，用来弥补线程上下文切换的开销。自旋锁常用在加锁时间比较短的代码上。
读写锁
读写锁有三种状态：读加锁状态、写加锁状态和不加锁状态 
只有一个线程可以占有写状态的锁，但可以有多个线程同时占有读状态锁，这也是它可以实现高并发的原因。当其处于写状态锁下，任何想要尝试获得锁的线程都会被阻塞，直到写状态锁被释放；所以读写锁非常适合资源的读操作远多于写操作的情况。
原文链接：https://blog.csdn.net/judgejames/article/details/87286397

### 2. 说说c++ move函数？
move是转移对象的所有权，所以我们可以move的是可以转移所有权的对象。
C++，我们可以移动右值，也可以把左值通过std::move变成右值，从而可以实现移动。

### 3. 说说c++的左值和右值？什么时候用到右值？
在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。
C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。



